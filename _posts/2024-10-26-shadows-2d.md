---
layout: post
title: A shader for 2D shadows
author: Alexandre
tags:
- gobs-and-gods
- gamedev
- shaders
- godot
toc:  false
---

There are basically two cheap ways to get shadows on a 2D game: prebacking the shadows in the images, or using a shader.

## prebacked images
The first solution is simple: just draw the shadows on the sprite. (Or add a specific sprite with only the object shadow.)
![a tree with a shadow]({{ 'assets/images/shadows/tree_withshadow.png' | relative_url }})
*sprite with shadow directly on the image*

This approach certainly is the simplest, but it suffers a few limitations:
- the required texture is larger, meaning a little more pressure on the GPU
- the shadow is static and cannot be changed dynamically
- it may require more work for the artist. (Or a preprocessing step in the asset pipeline.)
- it does not interact well with other shaders such as contour shaders

![outline on a sprite with shadow]({{ 'assets/images/shadows/tree_shadow_outline.png' | relative_url }})
*outline on a sprite with shadow. Actually not ugly as I expected, but I'm think that's a bit lucky*

- and finally, it does not work when the image casting the shadow is made of several sprites.

This final limitation is the main issue in the case of Gobs: all our characters are made of several sprites, for their body parts and equipped items. Like this:
![]({{ 'assets/images/shadows/gob_components3.png' | relative_url }})
*A NPC components. The equipment can be looted and equipped on player's Gobs*

For this reason, I used a shader instead.


## 2D shadows with a Shader

The other solution is to write a shader to compute the shadow directly on the GPU.

The basic computation is actually quite straightforward:
- on current pixel (x,y), the pixel which may cast a shadow here is located at "(x,y) - (y - yBottom) * shadowDirection"
- just read this pixel color and merge it with the current pixel to get the image with a shadow.

![ Pixel casting a shadow on (x,y)]({{ 'assets/images/shadows/shadow_explained.jpg' | relative_url }})
yBottom here is a parameter of the shader, which controls where the shadow is 'rooted'.

This gives us a  "basic" shader like this:
```
shader_type canvas_item;
render_mode blend_mix;

uniform float _yBottom = 0.95; // Bottom of the sprite (in UV coordinates.)
uniform vec4 modulate : hint_color;
uniform vec2 shadowDirection = vec2(0.5, 0.5); 

void fragment() {

	// height of the pixel
	float dy =  clamp(_yBottom - UV.y, 0.0 , 1.0) ;
	// point casting the shadow
	vec2 shadowUV = UV - dy * shadowDirection;
		
	// read shadow-casting pixel color
	vec4 shadow = vec4(modulate.rgb, texture(TEXTURE, shadowUV).a * modulate.a);

	// read color of current pixel
	vec4 col = texture(TEXTURE, correctedUV);
	
	// mix current pixel with shadow behind.
	COLOR = mix(shadow, col, col.a);
}
```

But of course, this naive shader has several issues:
- First, the shadow pixel may be outside of the texture box, and thus would not be rendered.
- then, the shadow angle with this implementation depends on the size ratio of the texture.

To solve this, I needed to expand the area where the texture is displayed in the 'vertex' function, and to define the shadow direction in pixel space instead of UV space.
The final shader can be found [on godotshaders](https://godotshaders.com/shader/2d-shadow-with-bottom-offset-image-ratio-independent-shadow-direction-and-minimal-vertex-increase/).

### Applying the shader on the Gobs

So I could not precompute the goblins shadows because goblins are made of several sprites.
But a shader is applied to a single sprite, so it shouldn't work either, right?
Indeed. But there is a workaround for that in Godot.
It requires to make a new viewport, add the different components as children of the viewport, and use this viewport texture on a sprite. Setting the "shadows" shader on this sprite gives the intended result.

Sounds complicated?  Of course, this introduce a bit of an overhead, but once correctly packaged it is not so bad.
I have a class which looks like the 'MultiSprite' one below. Then I just add components as children of the multiSprite.WorldContainer , and I can set a shader on this "multisprite" just as if it was a normal sprite.  

```
public class MultiSprite : Sprite
{
    // a sprite using a viewport texture.
    // Set subcomponents as children of WorldContainer to view them on this sprite.

    readonly Viewport _viewport;
    readonly Node2D _container;
    public readonly Vector2 _size;
    public Node2D WorldContainer => _container;

    const int MultiSpriteSize = 256;
    public MultiSprite()
    {
        _size = Vector2.One * MultiSpriteSize;
        _viewport = new Viewport();
        base.AddChild(_viewport);
        _viewport.RenderTargetClearMode = Viewport.ClearMode.Always;
        _viewport.RenderTargetUpdateMode = Viewport.UpdateMode.WhenVisible;
        _viewport.SetProcessInput(false);
        _viewport.TransparentBg = true;
        _viewport.Size = _size;

        _viewport.Usage = Viewport.UsageEnum.Usage2d;

        _container = new Godot.Node2D();
        _viewport.AddChild(_container);
        _container.Position = _size / 2;

        var texture = _viewport.GetTexture();
        this.Texture = texture;
        this.FlipV = true;
        Texture.Flags = TextureFlagMipmapsAndFilter;
    }
    const uint TextureFlagMipmapsAndFilter = (uint)Texture.FlagsEnum.Mipmaps + (uint)Texture.FlagsEnum.Filter;   

}
```
 